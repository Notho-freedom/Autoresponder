"""
Service de gestion de la base de données Firestore
Gère l'enregistrement et la vérification des réponses déjà traitées
Compatible avec le déploiement cloud (Render, Railway, etc.)
"""
import os
import json
import time
from datetime import datetime
from typing import Optional, List, Dict

import firebase_admin
from firebase_admin import credentials, firestore

from config.constants import ErrorMessages, SuccessMessages, Config
from utils.logger import setup_logger

logger = setup_logger(__name__)


class FirestoreService:
    def __init__(self, credentials_path: Optional[str] = None, credentials_json: Optional[str] = None):
        """
        Initialise la connexion à Firestore
        
        Args:
            credentials_path: Chemin vers le fichier credentials JSON
            credentials_json: JSON credentials en string (pour variables d'environnement)
        """
        self.collection_name = "responses"
        self._stats_cache = None
        self._stats_cache_time = 0
        
        # Initialiser Firebase si pas déjà fait
        if not firebase_admin._apps:
            try:
                if credentials_json:
                    # Depuis variable d'environnement (production)
                    cred_dict = json.loads(credentials_json)
                    cred = credentials.Certificate(cred_dict)
                elif credentials_path and os.path.exists(credentials_path):
                    # Depuis fichier local (développement)
                    cred = credentials.Certificate(credentials_path)
                else:
                    # Essayer les credentials par défaut de l'environnement
                    cred = credentials.ApplicationDefault()
                
                firebase_admin.initialize_app(cred)
                logger.info(SuccessMessages.SERVICE_INITIALIZED.format(service="Firestore"))
            except Exception as e:
                logger.error(ErrorMessages.FIRESTORE_INIT_FAILED.format(error=str(e)))
                raise ValueError(ErrorMessages.FIRESTORE_INIT_FAILED.format(error=str(e)))
        
        self.db = firestore.client()
    def already_sent(self, response_id: str) -> bool:
        """
        Vérifie si une réponse a déjà été traitée
        
        Args:
            response_id: Identifiant unique de la réponse
            
        Returns:
            True si déjà envoyé, False sinon
        """
        try:
            doc = self.collection.document(response_id).get()
            return doc.exists
        except Exception as e:
            logger.error(ErrorMessages.FIRESTORE_QUERY_FAILED.format(error=str(e)))
            return False
    
    def add_response(self, response_id: str, email: str, phone: str, 
                    sent_mail: bool = True, sent_sms: bool = True) -> bool:
        """
        Ajoute une nouvelle réponse traitée dans Firestore
        
        Args:
            response_id: Identifiant unique de la réponse
            email: Adresse e-mail du répondant
            phone: Numéro de téléphone du répondant
            sent_mail: Statut d'envoi du mail
            sent_sms: Statut d'envoi du SMS
            
        Returns:
            True si ajouté avec succès, False si déjà existant
        """
        if self.already_sent(response_id):
            return False
        
        try:
            doc_data = {
                "responseId": response_id,
                "email": email,
                "phone": phone,
                "sent_mail": sent_mail,
                "sent_sms": sent_sms,
                "timestamp": datetime.utcnow().isoformat() + "Z",
                "created_at": firestore.SERVER_TIMESTAMP
            }
            
            self.collection.document(response_id).set(doc_data)
            logger.info(SuccessMessages.RESPONSE_RECORDED.format(response_id=response_id))
            
            # Invalider le cache des stats
            self._invalidate_stats_cache()
            return True
            
        except Exception as e:
            logger.error(ErrorMessages.FIRESTORE_WRITE_FAILED.format(error=str(e)))
            return False
    
    def get_response(self, response_id: str) -> Optional[Dict]:
        """
        Récupère une réponse spécifique par son ID
        
        Args:
            response_id: Identifiant unique de la réponse
            
        Returns:
            if doc.exists:
                return doc.to_dict()
            return None
        except Exception as e:
            logger.error(ErrorMessages.FIRESTORE_QUERY_FAILED.format(error=str(e)))
            return Nonedoc.to_dict()
            return None
        except Exception as e:
            print(f"Erreur lors de la récupération: {str(e)}")
            return None
    
    def get_all_responses(self, limit: int = 100) -> List[Dict]:
        """
        Récupère toutes les réponses enregistrées
        
        Args:
            limit: Nombre maximum de résultats à retourner
            
            docs = self.collection.limit(limit).stream()
            results = [doc.to_dict() for doc in docs]
            logger.info(SuccessMessages.DATA_RETRIEVED.format(count=len(results)))
            return results
        except Exception as e:
            logger.error(ErrorMessages.FIRESTORE_QUERY_FAILED.format(error=str(e)))
            return []lf.collection.limit(limit).stream()
            return [doc.to_dict() for doc in docs]
        except Exception as e:
            print(f"Erreur lors de la récupération: {str(e)}")
            return []
    
    def get_stats(self) -> Dict:
        """
        Génère des statistiques sur les envois avec caching
        Cache pendant 5 minutes pour éviter les requêtes coûteuses
        
        Returns:
            Dictionnaire avec les statistiques
        """
        # Vérifier le cache
        current_time = time.time()
        if self._stats_cache and (current_time - self._stats_cache_time) < Config.STATS_CACHE_TTL:
            logger.debug("Returning cached stats")
            return self._stats_cache
        
        try:
            # Utiliser aggregation_query si disponible (Firestore v10+)
            # Sinon, fallback sur count query
            from firebase_admin import firestore as admin_firestore
            
            # Compter tous les documents (optimisé)
            total_query = self.collection.count()
            total_result = total_query.get()
            total = total_result[0][0].value if total_result else 0
            
            # Compter les emails envoyés
            mail_query = self.collection.where('sent_mail', '==', True).count()
            mail_result = mail_query.get()
            mails_sent = mail_result[0][0].value if mail_result else 0
            
            # Compter les SMS envoyés
            sms_query = self.collection.where('sent_sms', '==', True).count()
            sms_result = sms_query.get()
            sms_sent = sms_result[0][0].value if sms_result else 0
            
            stats = {
                "total_responses": total,
                "mails_sent": mails_sent,
                "sms_sent": sms_sent,
                "success_rate": 100 if total == 0 else round((mails_sent + sms_sent) / (total * 2) * 100, 2)
            }
            
            # Mettre en cache
            self._stats_cache = stats
            self._stats_cache_time = current_time
            
            logger.info(f"Stats calculated: {total} responses, {mails_sent} emails, {sms_sent} SMS")
            return stats
            
        except Exception as e:
            logger.error(f"Failed to calculate stats (using old method): {str(e)}")
            # Fallback sur l'ancienne méthode si count() n'est pas disponible
            return self._get_stats_fallback()
    
    def _get_stats_fallback(self) -> Dict:
        """
        Méthode fallback pour get_stats (moins efficace mais compatible)
        Utilisée si count() n'est pas disponible
        
        Returns:
            Dictionnaire avec les statistiques
        """
        try:
            docs = self.collection.limit(1000).stream()  # Limiter pour éviter timeout
        try:
            self.collection.document(response_id).delete()
            self._invalidate_stats_cache()
            logger.info(f"Response deleted: {response_id}")
            return True
        except Exception as e:
            logger.error(ErrorMessages.FIRESTORE_DELETE_FAILED.format(error=str(e)))
            return Falseocs:
                data = doc.to_dict()
                total += 1
                if data.get('sent_mail', False):
                    mails_sent += 1
                if data.get('sent_sms', False):
                    sms_sent += 1
            
            return {
                "total_responses": total,
                "mails_sent": mails_sent,
                "sms_sent": sms_sent,
                "success_rate": 100 if total == 0 else round((mails_sent + sms_sent) / (total * 2) * 100, 2),
                "note": "Limited to 1000 most recent responses"
            }
        except Exception as e:
            logger.error(ErrorMessages.FIRESTORE_QUERY_FAILED.format(error=str(e)))
            return {
                "total_responses": 0,
                "mails_sent": 0,
                "sms_sent": 0,
                "success_rate": 0,
                "error": str(e)
            }
    
    def _invalidate_stats_cache(self):
        """Invalide le cache des statistiques"""
        self._stats_cache = None
        self._stats_cache_time = 0
    
    def delete_response(self, response_id: str) -> bool:
        """
        Supprime une réponse (utile pour les tests)
        
        Args:
            response_id: Identifiant de la réponse à supprimer
            
        Returns:
            True si supprimé avec succès
        """
        try:
            self.collection.document(response_id).delete()
            self._invalidate_stats_cache()
            logger.info(f"Response deleted: {response_id}")
            return True
        except Exception as e:
            logger.error(ErrorMessages.FIRESTORE_DELETE_FAILED.format(error=str(e)))
            return False
    
    def clear_all(self) -> bool:
        """
        Supprime toutes les réponses (ATTENTION: action irréversible!)
        Utiliser uniquement pour les tests
        
        Returns:
            True si réussi
        """
        try:
            docs = self.collection.stream()
            deleted_count = 0
            for doc in docs:
                doc.reference.delete()
                deleted_count += 1
            
            self._invalidate_stats_cache()
            logger.warning(f"Cleared all Firestore data: {deleted_count} documents deleted")
            return True
        except Exception as e:
            logger.error(ErrorMessages.FIRESTORE_DELETE_FAILED.format(error=str(e)))
            return False
