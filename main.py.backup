"""
Application FastAPI principale
Microservice de r√©ponse automatique aux formulaires Google
Version optimis√©e avec logging centralis√© et gestion am√©lior√©e des services
"""
import os
import hashlib
from typing import Dict, Any, Optional
from datetime import datetime

from fastapi import FastAPI, HTTPException, Header, Request
from fastapi.responses import JSONResponse
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel, EmailStr, field_validator
from dotenv import load_dotenv

from config.constants import Config, ErrorMessages, InfoMessages, APIResponses, StatusCodes
from utils.logger import setup_logger
from utils.service_manager import service_manager
from utils.validators import is_valid_email, is_valid_phone, normalize_phone, sanitize_name

# Charger les variables d'environnement
load_dotenv()

# Logger
logger = setup_logger(__name__)

# Cl√© secr√®te pour authentification webhook
SECRET_KEY = os.getenv('SECRET_KEY', 'your_secret_key_here')

# Initialiser l'application FastAPI
app = FastAPI(
    title=Config.APP_NAME,
    description="Microservice d'envoi automatique d'e-mails et SMS lors de soumissions de formulaires Google",
    version=Config.APP_VERSION
)

# Configuration CORS pour accepter les requ√™tes de Google Apps Script
app.add_middleware(
    CORSMiddleware,
    allow_origins=[
        "https://script.google.com",
        "https://script.googleusercontent.com",
        "*"  # En production, remplacez par votre domaine sp√©cifique
    ],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)


# Mod√®les Pydantic avec validation am√©lior√©e
class FormResponse(BaseModel):
    """Mod√®le de r√©ponse du formulaire Google avec validation"""
    email: EmailStr
    phone: str
    name: Optional[str] = None
    timestamp: Optional[str] = None
    
    @field_validator('phone')
    @classmethod
    def validate_phone(cls, v: str) -> str:
        """Valide et normalise le num√©ro de t√©l√©phone"""
        if not is_valid_phone(v):
            raise ValueError(ErrorMessages.INVALID_PHONE.format(phone=v))
        return normalize_phone(v)
    
    @field_validator('name')
    @classmethod
    def validate_name(cls, v: Optional[str]) -> Optional[str]:
        """Nettoie et valide le nom"""
        if v:
            return sanitize_name(v)
        return v



# Fonctions utilitaires
def verify_secret_key(authorization: Optional[str]) -> bool:
        if not sms_service:
            sms_service = SMSService()
    except Exception as e:
        print(f"Erreur lors de l'initialisation des services: {str(e)}")


def verify_secret_key(authorization: Optional[str]) -> bool:
    """
    V√©rifie la cl√© secr√®te dans le header Authorization
    
    Args:
        authorization: Valeur du header Authorization
        
    Returns:
        True si la cl√© est valide
    """
    if not authorization:
        return False
    
    # Format attendu: "Bearer <secret_key>"
    try:
    """
    if not authorization:
        return False
    
    # Format attendu: "Bearer <secret_key>"
    try:
        scheme, token = authorization.split(maxsplit=1)
        if scheme.lower() != 'bearer':
            return False
        return token == SECRET_KEY
    except ValueError:
        return False
    Args:
        email: E-mail du r√©pondant
        phone: T√©l√©phone du r√©pondant
        timestamp: Timestamp de la r√©ponse
        
    Returns:
        ID unique hash√©
    """
    if not timestamp:
        timestamp = datetime.utcnow().isoformat()
    
    data = f"{email}:{phone}:{timestamp}"
    return hashlib.sha256(data.encode()).hexdigest()[:16]


# Routes API
@app.get("/")
async def root():
    """Route racine - Information sur l'API"""
    return {
        "service": "Google Forms Auto-Responder",
        "version": "1.0.0",
        "status": "running",
        "endpoints": {
            "status": "/api/status",
            "receive": "/api/receive (POST)"
        }
    }

@app.get("/")
async def root():
    """Route racine - Information sur l'API"""
    return APIResponses.success(
        data={
            "service": Config.APP_NAME,
            "version": Config.APP_VERSION,
            "endpoints": {
                "status": "/api/status",
                "receive": "/api/receive (POST)"
            }
        },
        message="API is running"
    )ms_ok = sms_service.test_connection() if sms_service else False
@app.get("/api/status", response_model=StatusResponse)
async def check_status():
    """
    Endpoint de v√©rification du statut du service
    Retourne l'√©tat des diff√©rents services et statistiques (avec cache)
    """
    try:
        # V√©rifier l'√©tat des services via le service manager
        health_status = service_manager.health_check()
        
        # R√©cup√©rer les statistiques (avec cache de 5 minutes)
        stats = service_manager.get_stats()
        
        return StatusResponse(
            status="operational" if all(health_status.values()) else "degraded",
            timestamp=datetime.utcnow().isoformat() + "Z",
            services=health_status,
            stats=stats
        )
    except Exception as e:
        logger.error(f"Status check failed: {str(e)}")
        raise HTTPException(
            status_code=StatusCodes.INTERNAL_ERROR,
            detail=f"Status check failed: {str(e)}"
        )orkflow:
    1. V√©rifie l'authentification
    2. Parse les donn√©es re√ßues
    3. V√©rifie si d√©j√† trait√©
    4. Envoie e-mail et SMS
    5. Enregistre dans la base locale
    
    Headers requis:
        Authorization: Bearer <secret_key>
    
    Body (JSON):
        {
            "email": "user@example.com",
            "phone": "+237xxxxxxxx",
            "name": "Nom Pr√©nom",
            "timestamp": "2025-11-08T20:00:00Z"
        }
    """
    # V√©rifier l'authentification
    if not verify_secret_key(authorization):
        raise HTTPException(
            status_code=401,
            detail="Unauthorized: Invalid or missing secret key"
        )
    
    # Initialiser les services si n√©cessaire
    initialize_services()
    
    try:
        # Parser les donn√©es re√ßues
        data = await request.json()
        
        # Extraire les champs n√©cessaires
        # Google Apps Script peut envoyer les donn√©es sous diff√©rents formats
        # On supporte √† la fois le format direct et le format namedValues
        if isinstance(data, dict) and 'namedValues' in data:
            # Format Google Apps Script standard
            named_values = data['namedValues']
            email = named_values.get('Adresse e-mail', named_values.get('Email', ['']))[0]
            phone = named_values.get('T√©l√©phone', named_values.get('Phone', ['']))[0]
            name = named_values.get('Nom', named_values.get('Name', ['']))[0]
            timestamp = data.get('timestamp', datetime.utcnow().isoformat())
        else:
            # Format direct
            email = data.get('email')
            phone = data.get('phone')
            name = data.get('name')
            timestamp = data.get('timestamp', datetime.utcnow().isoformat())
        
        # Valider les donn√©es
        if not email or not phone:
            raise HTTPException(
                status_code=400,
                detail="Missing required fields: email and phone are mandatory"
            )
        
        # G√©n√©rer un ID unique pour cette r√©ponse
        response_id = generate_response_id(email, phone, timestamp)
        
        # V√©rifier si d√©j√† trait√©
        if db_service.already_sent(response_id):
        
        # Envoi des messages (avec gestion d'erreurs robuste)
        mail_sent = False
        sms_sent = False
        errors = []
        
        # Envoyer l'e-mail
        try:
            mail_sent = service_manager.email_service.send_confirmation_email(email, name)
            if not mail_sent:
                errors.append("Email sending failed")
        except Exception as e:
            logger.error(f"Email error: {str(e)}")
            errors.append(f"Email error: {str(e)}")
        
        # Envoyer le SMS
        try:
            sms_sent = service_manager.sms_service.send_confirmation_sms(phone, name)
            if not sms_sent:
                errors.append("SMS sending failed")
        except Exception as e:
            logger.error(f"SMS error: {str(e)}")
            errors.append(f"SMS error: {str(e)}")
        
        # Enregistrer dans la base de donn√©es
        service_manager.db_service.add_response(
            response_id=response_id,
            email=email,
            phone=phone,
            sent_mail=mail_sent,
            sent_sms=sms_sent
        )
        
        logger.info(InfoMessages.PARTIAL_SUCCESS.format(email_ok=mail_sent, sms_ok=sms_sent))
        
        # Construire la r√©ponse
        response_data = {
            "response_id": response_id,
            "processed": {
                "email": mail_sent,
                "sms": sms_sent
            },
            "timestamp": datetime.utcnow().isoformat() + "Z"
        }
        
        if errors:
            response_data["errors"] = errors
        
        status_code = StatusCodes.OK if mail_sent and sms_sent else StatusCodes.PARTIAL_SUCCESS
        
        return JSONResponse(
            status_code=status_code,
            content=APIResponses.success(
                data=response_data,
                message=InfoMessages.RESPONSE_PROCESSED if mail_sent and sms_sent else "Partial success"
            )
        )
        
    except HTTPException:
        raise
    except Exception as e:
        logger.error(ErrorMessages.PROCESSING_FAILED.format(error=str(e)))
        raise HTTPException(
            status_code=StatusCodes.INTERNAL_ERROR,
            detail=ErrorMessages.PROCESSING_FAILED.format(error=str(e))
        )

@app.get("/api/responses")
async def get_all_responses(authorization: Optional[str] = Header(None)):
    """
    R√©cup√®re toutes les r√©ponses enregistr√©es
    (Endpoint d'administration - n√©cessite authentification)
    """
    if not verify_secret_key(authorization):
        raise HTTPException(
            status_code=StatusCodes.UNAUTHORIZED,
            detail=ErrorMessages.UNAUTHORIZED
        )
    
    responses = service_manager.db_service.get_all_responses()
    return APIResponses.success(
        data={
            "total": len(responses),
            "responses": responses
        }
@app.on_event("startup")
async def startup_event():
    """Initialisation au d√©marrage de l'application"""
    logger.info(InfoMessages.STARTUP.format(app_name=Config.APP_NAME, version=Config.APP_VERSION))
    # Les services seront initialis√©s √† la demande (lazy loading)
    logger.info(InfoMessages.SERVICE_READY)


@app.on_event("shutdown")
async def shutdown_event():
    """Nettoyage √† l'arr√™t de l'application"""
    logger.info(InfoMessages.SHUTDOWN.format(app_name=Config.APP_NAME))

@app.on_event("shutdown")
async def shutdown_event():
    """Nettoyage √† l'arr√™t de l'application"""
    print("üõë Shutting down Google Forms Auto-Responder...")


# Point d'entr√©e pour ex√©cution directe
if __name__ == "__main__":
    import uvicorn
    
    host = os.getenv('HOST', '0.0.0.0')
    port = int(os.getenv('PORT', 8000))
    
    uvicorn.run(
        "main:app",
        host=host,
        port=port,
        reload=True,
        log_level="info"
    )
